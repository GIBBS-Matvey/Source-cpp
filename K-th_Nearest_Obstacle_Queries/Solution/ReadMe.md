### Решение.

Для начала `отсортируем первые k максимальных значений` в массиве, оставшиеся элементы можно проигнорировать.

После сортировки $k$-ый максимум окажется в ячейке с индексом $k-1$.

![Иллюстрация к проекту](https://github.com/GiBBS-Matvey/Source-cpp/raw/master/K-th_Nearest_Obstacle_Queries/Images/K_nearest_obstacles(last).png)


Далее из первых $k$ элементов массива `построим "Пирамиду по минимуму"`. Это делается для того чтобы в дальнейшем иметь быстрый доступ к $k$-му максимуму, ибо `k-ый максимум в массиве - это минимальный элемент среди k самый больших элементов.`

![Иллюстрация к проекту](https://github.com/GiBBS-Matvey/Source-cpp/raw/master/K-th_Nearest_Obstacle_Queries/Images/Pyramid_K_Nearest(final).jpg)

Далее необходимо поддерживать $k$-ый максимум при добавлении новых элементов. Это делается следующим образом:
- Если новый элемент больше текущего $k$-го максимума, тогда добавляем этот элемент в пирамиду, а текущий $k$-ый максимум удаляем.
  Добавление и удаление из пирамиды производится за $O(lg(k))$.
- Если новый элемент меньше или равен текущему $k$-ому максимуму, игнорируем его.


 P.S. Непосредственно в этой задаче необходимо поддерживать логику не $k$-го максимума, а $k$-го минимума. Это симметричная задача - необходимо хранить $k$ минимальных элементов в "Пирамиде по максимуму". Дальнейшие рассуждения аналогичны.
 

### Complexity: $O(n\cdot lg(k))$
