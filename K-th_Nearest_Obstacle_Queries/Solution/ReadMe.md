### Решение.

Для начала `отсортируем первые k максимальных значений` в массиве, про оставшиеся можно забыть, они нам не понадобятся.

После сортировки $k$-ый максимум окажется в ячейке с индексом $k-1$.

![Иллюстрация к проекту](https://github.com/GiBBS-Matvey/Source-cpp/raw/master/K-th_Nearest_Obstacle_Queries/Images/K_nearest_obstacles(last).png)


Далее из первых $k$ элементов массива `построим "Пирамиду по минимуму"`: это делается для того чтобы в дальнейшем иметь быстрый доступ к $k$-му максимуму, ибо `$k$-ый максимум в массиве - это минимальный элемент среди $k$ самый больших элементов.`

![Иллюстрация к проекту](https://github.com/GiBBS-Matvey/Source-cpp/raw/master/K-th_Nearest_Obstacle_Queries/Images/Pyramid_K_Nearest(last).jpg)

Далее необходимо поддерживать $k$-ый максимум при добавлении новых элементов. Это делается следующим образом:
- Если новый элемент больше текущего $k$-го максимума, значит, добавляем этот элемент в пирамиду, а текущий $k$-ый максимум удаляем.
  Добавление и удаление из пирамиды производится за $O(lg(k))$.
- Если новый элемент меньше или равен текущему максимуму, значит, это значение не нужно.

##### Complexity: $O(n\cdot lg(k))$
