### Описание идеи решения.
Для решения данной задачи можно построить `Бор`, где каждой вершине ставится в однозначное соответствие некоторый префикс некоторого слова из словаря. 

Каждая вершина Бора хранит в себе 
- `map` - словарь (дерево поиска), в котором содержатся указатели на "потомков" данной вершины.
- `max_popularity` - максимальная популярность среди всех слов, имеющих данный префикс.
- `index` - индекс (в исходной нумерации) слова, чей `max_popularity` хранится в данной вершине.
- `parent` - указатель на "родителя" данной вершины.

После построения Бора необходимо обработать все запросы. Изначально ставим указатель на корень Бора. После этого
- на запрос вида "+ c" ищем в $map$ текущей вершины символ $c$. Если находим таковой, смещаемся в новую вершину, при этом выводим поле `max_popularity' новой вершины.
Если не находим символ $c$, остаёмся в текущей вершине и выводим -1.
- на запрос вида "-" смещаемся из текущей вершины в её предка `parent` и выводим его `max_popularity`.

  ### Complexity:
  - На добавление одного слова $s_i$ в Бор уходит не более чем $2\cdot log(|A|)\cdot |s_i|$ операций, где $|A|$ - мощность алфавита (если, например, предположить,
  что символами могут являться только строчные латинские буквы, тогда $|A| = 25$).

  Пояснение: в худшем случае на добавление одного символа уходит $log(|A|)$ на поиск и столько же на его добавление, если такой символ не нашёлся.

  Тогда на построение всего Бора уходит $2\cdot log(|A|)\cdot \sum |s_i| \leq 10 \cdot 10^{6} = 10^{7}$ операций, что по времени составляет примерно $0.1$ секунду.


  - На обработку одного запроса уходит не более чем $log(|A|)$ операций (поиск нового символа в вершине, либо же "откат" к предку). В таком случае, на обработку всех
    запросов потратим не более чем $Q\cdot log(|A|) \leq 10^{5}\cdot 5)$, что по порядку выйдет около тысячной доли секунды.

### Итог: O($\sum s_i + Q$)
